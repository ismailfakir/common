package net.cloudcentrik.common.restclient;

import com.eclipsesource.json.Json;
import com.eclipsesource.json.JsonValue;
import net.cloudcentrik.common.restclient.oauth.HttpMethod;
import net.cloudcentrik.common.util.JsonUtil;
import net.cloudcentrik.common.util.XmlUtil;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.http.Header;
import org.apache.http.HttpEntity;
import org.apache.http.HttpHeaders;
import org.apache.http.NameValuePair;
import org.apache.http.client.config.RequestConfig;
import org.apache.http.client.methods.HttpUriRequest;
import org.apache.http.client.methods.RequestBuilder;
import org.apache.http.client.utils.URIBuilder;
import org.apache.http.config.Registry;
import org.apache.http.config.RegistryBuilder;
import org.apache.http.conn.socket.ConnectionSocketFactory;
import org.apache.http.conn.socket.PlainConnectionSocketFactory;
import org.apache.http.conn.ssl.DefaultHostnameVerifier;
import org.apache.http.conn.ssl.SSLConnectionSocketFactory;
import org.apache.http.conn.ssl.TrustSelfSignedStrategy;
import org.apache.http.entity.StringEntity;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;
import org.apache.http.message.BasicHeader;
import org.apache.http.message.BasicNameValuePair;
import org.apache.http.ssl.PrivateKeyDetails;
import org.apache.http.ssl.PrivateKeyStrategy;
import org.apache.http.ssl.SSLContexts;
import org.apache.oltu.oauth2.client.OAuthClient;
import org.apache.oltu.oauth2.client.URLConnectionClient;
import org.apache.oltu.oauth2.client.request.OAuthClientRequest;
import org.apache.oltu.oauth2.client.response.OAuthJSONAccessTokenResponse;
import org.apache.oltu.oauth2.common.message.types.GrantType;
import org.w3c.dom.Document;

import javax.net.ssl.SSLContext;
import java.io.FileInputStream;
import java.net.Socket;
import java.net.URI;
import java.security.KeyStore;
import java.util.Base64;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

public class RestClient {

    private static Log log = LogFactory.getLog(RestClient.class);

    /**
     * Path to your client-side SSL certificate in the PKCS12 format, as generated by OpenSSL.
     */
    private static final String KEY_STORE_PATH = "/path/to/pkcs12file.p12";

    /**
     * PKCS12 file passphrase.
     */
    private static final String KEY_STORE_PASSWORD = "correct horse battery staple";

    private static boolean isDebugEnabled = false;
    private static URI baseUrl = null;
    private static List<Header> defaultHeaders;
    private static CloseableHttpClient httpClient;
    private static RequestConfig requestConfig;
    private static PoolingHttpClientConnectionManager connectionManager;

    //private static CommonsHttpOAuthConsumer oAuth1aConsumer=null;

    private static RestClient ourInstance = new RestClient();

    private RestClient() {
    }

    public static RestClient getInstance(String url, Map<String, String> headers, Boolean isDebugable) throws Exception {

        isDebugEnabled = isDebugable;

        baseUrl = new URI(url);

        defaultHeaders = headers.entrySet().stream()
                .map(entry -> new BasicHeader(entry.getKey(), entry.getValue()))
                .collect(Collectors.toList());

        requestConfig = RequestConfig.custom()
                .setAuthenticationEnabled(true)
                .setSocketTimeout(6000)
                .setConnectTimeout(6000)
                .build();


        /*SSLContext sslContext = SSLContexts
                .custom()
                .loadTrustMaterial(null, new TrustSelfSignedStrategy())
                .build();

        SSLConnectionSocketFactory sslConnectionFactory = new SSLConnectionSocketFactory(sslContext,
                new DefaultHostnameVerifier());*/

        Registry<ConnectionSocketFactory> registry = RegistryBuilder.<ConnectionSocketFactory>create()
                //.register("https", sslConnectionFactory)
                .register("https", createSSLConnectionFactory(Boolean.TRUE))
                .register("http", new PlainConnectionSocketFactory())
                .build();


        connectionManager = new PoolingHttpClientConnectionManager(registry);
        connectionManager.setMaxTotal(200);
        connectionManager.setDefaultMaxPerRoute(20);

        httpClient = HttpClients.custom()
                .setDefaultRequestConfig(requestConfig)
                .setDefaultHeaders(defaultHeaders)
                .addInterceptorLast(new HttpRequestInterceptorImpl(isDebugEnabled))
                .addInterceptorLast(new HttpResponseInterceptorImpl(isDebugEnabled))
                .setConnectionManager(connectionManager)
                .build();

        return ourInstance;
    }

    public static String parseBasicAuthorizationHeader(String user, String password) throws Exception {
        String basicAuthorizationHeader = "";
        byte[] bytes = new String(user + ":" + password).getBytes("UTF-8");
        basicAuthorizationHeader = "Basic " + Base64.getEncoder().encodeToString(bytes);
        return basicAuthorizationHeader;
    }

    public static RestClient getBasicJsonClient(String baseUrl, String user, String password, Map<String, String> customHeaders, boolean isDebugEnabled) throws Exception {
        Map<String, String> headers = new HashMap<String, String>();
        headers.put(HttpHeaders.CONTENT_TYPE, "application/json");
        headers.put(HttpHeaders.ACCEPT, "application/json");
        headers.put("Authorization", parseBasicAuthorizationHeader(user, password));
        if (customHeaders != null) {
            headers.putAll(customHeaders);
        }
        return getInstance(baseUrl, headers, isDebugEnabled);
    }

    public static RestClient getOAuth1aJsonClient(String baseUrl, String consumerKey, String consumerSecret,String accessToken,String accessTokenSecret, Map<String, String> customHeaders, boolean isDebugEnabled) throws Exception {
        Map<String, String> headers = new HashMap<String, String>();
        headers.put(HttpHeaders.CONTENT_TYPE, "application/json");
        headers.put(HttpHeaders.ACCEPT, "application/json");

        if (customHeaders != null) {
            headers.putAll(customHeaders);
        }

        /*oAuth1aConsumer = new CommonsHttpOAuthConsumer(consumerKey, consumerSecret);
        oAuth1aConsumer.setTokenWithSecret(accessToken, accessTokenSecret);*/

        return getInstance(baseUrl, headers, isDebugEnabled);
    }

    public static RestClient getOAuth2JsonClient(String baseUrl, String consumerKey, String consumerSecret,String accessToken,String accessTokenSecret, Map<String, String> customHeaders, boolean isDebugEnabled) throws Exception {
        Map<String, String> headers = new HashMap<String, String>();
        headers.put(HttpHeaders.CONTENT_TYPE, "application/json");
        headers.put(HttpHeaders.ACCEPT, "application/json");

        String tempAccessToken="";
        OAuthClientRequest request = OAuthClientRequest
                .tokenLocation("https://api.vasttrafik.se/token/")
                .setClientId("L3OkTVwZUdHCUVerTO7HSYqpBmoa")
                .setClientSecret("zRYffCS07dTaIc3L4c9T3Evfg2Qa")
                .setGrantType(GrantType.CLIENT_CREDENTIALS)
                .setScope("99099")
                .buildQueryMessage();
        //create OAuth client that uses custom http client under the hood
        OAuthClient oAuthClient = new OAuthClient(new URLConnectionClient());

        OAuthJSONAccessTokenResponse tokenResponseJson=oAuthClient.accessToken(request);
        tempAccessToken=tokenResponseJson.getAccessToken();

        System.out.println("Access Token : "+tempAccessToken);

        headers.put("Authorization","Bearer "+tempAccessToken);

        if (customHeaders != null) {
            headers.putAll(customHeaders);
        }

        return getInstance(baseUrl, headers, isDebugEnabled);
    }

    public static RestClient getJsonClient(String baseUrl, Map<String, String> customHeaders, boolean isDebugEnabled) throws Exception {
        Map<String, String> headers = new HashMap<String, String>();
        headers.put(HttpHeaders.CONTENT_TYPE, "application/json");
        headers.put(HttpHeaders.ACCEPT, "application/json");
        if (customHeaders != null) {
            headers.putAll(customHeaders);
        }
        return getInstance(baseUrl, headers, isDebugEnabled);
    }

    public static RestClient getXmlClient(String baseUrl, Map<String, String> customHeaders, boolean isDebugEnabled) throws Exception {
        Map<String, String> headers = new HashMap<String, String>();
        headers.put(HttpHeaders.CONTENT_TYPE, "application/xml ");
        headers.put(HttpHeaders.ACCEPT, "application/xml");
        if (customHeaders != null) {
            headers.putAll(customHeaders);
        }

        return getInstance(baseUrl, headers, isDebugEnabled);
    }

    private JsonValue baseJsonRequest(String httpMethod, String path, HttpEntity entity, Map<String, String> params) throws Exception {

        JsonValue jsonResponse = null;

        jsonResponse = Json.parse(baseRequest(httpMethod, path, entity, params));
        if (isDebugEnabled) {
            JsonUtil.prettyPrint(jsonResponse);
        }

        return jsonResponse;
    }

    private Document baseXmlRequest(String httpMethod, String path, HttpEntity entity, Map<String, String> params) throws Exception {

        Document document = null;

        document = XmlUtil.convertStringToDocument(baseRequest(httpMethod, path, entity, params));
        if (isDebugEnabled) {
            XmlUtil.prettyPrint(document);
        }

        return document;
    }

    private String baseRequest(String httpMethod, String path, HttpEntity entity, Map<String, String> params) throws Exception {

        String stringResponse = null;
        HttpUriRequest request = null;
        URIBuilder uriBuilder = new URIBuilder();

        //parametes
        if (params != null) {
            List<NameValuePair> paramList = params.entrySet().stream()
                    .map(entry -> new BasicNameValuePair(entry.getKey(), entry.getValue()))
                    .collect(Collectors.toList());
            uriBuilder.addParameters(paramList);
        }

        //path
        if (path != null) {
            baseUrl = URI.create(baseUrl + path);

        }
        //url
        URI uri = uriBuilder
                .setScheme(baseUrl.getScheme())
                .setHost(baseUrl.getHost())
                .setPath(baseUrl.getPath())
                .build();

        //http request
        if (httpMethod.equals(HttpMethod.GET)) {
            request = RequestBuilder.get()
                    .setUri(uri)
                    .build();
        } else if (httpMethod.equals(HttpMethod.POST)) {
            request = RequestBuilder.post()
                    .setUri(uri)
                    .setEntity(entity)
                    .build();
        } else if (httpMethod.equals(HttpMethod.PUT)) {
            request = RequestBuilder.put()
                    .setUri(uri)
                    .setEntity(entity)
                    .build();
        } else if (httpMethod.equals(HttpMethod.DELETE)) {
            request = RequestBuilder.delete()
                    .setUri(uri)
                    .build();
        }

        //oauth1a signing
        /*if(oAuth1aConsumer!=null){
            oAuth1aConsumer.sign(request);
            *//*SignatureBaseString sbs = new SignatureBaseString(new HttpPost(
                    "http://example.com"), OAUTH_PARAMS);*//*
            //System.out.println(request.getURI().toString());
            //request.setHeader(OAuth.HTTP_AUTHORIZATION_HEADER, header);
            //request.addHeader("Authorization",oAuth1aConsumer);
        }*/

        stringResponse = httpClient.execute(request, new StringResponseHandler());
        if (isDebugEnabled) {
            System.out.println(stringResponse);
        }

        return stringResponse;
    }

    public Document getXmlResponse(String path, Map<String, String> params) throws Exception {

        return baseXmlRequest(HttpMethod.GET.name(), path, null, params);
    }

    public JsonValue getRequest(String path, Map<String, String> params) throws Exception {

        return baseJsonRequest(HttpMethod.GET.name(), path, null, params);
    }

    public JsonValue postRequest(String path, Map<String, String> params, JsonValue jsonValue) throws Exception {

        HttpEntity entity = new StringEntity(jsonValue.toString());
        return baseJsonRequest(HttpMethod.POST.name(), path, entity, params);
    }

    public JsonValue putRequest(String path, Map<String, String> params, JsonValue jsonValue) throws Exception {

        HttpEntity entity = new StringEntity(jsonValue.toString());
        return baseJsonRequest(HttpMethod.PUT.name(), path, entity, params);
    }

    public JsonValue putHttpEntityRequest(String path, Map<String, String> params, HttpEntity entity) throws Exception {

        return baseJsonRequest(HttpMethod.PUT.name(), path, entity, params);
    }

    /*
     * TODO: How to load key store for ssl secvurity
     * You need to create a keystore that containts the trusted CAs i.e. trust.jks. In this keystore you should put only
     * the certificate of the server that your application is going to connect. Then, you need a keystore for the identity
     * of the server i.e. identity.jks. In this keystore you should store put the private key + certificate + CA chain under
     * an alias (a name) that your application is going to use to authenticate itself with the server.
     */
    public static SSLConnectionSocketFactory createSSLConnectionFactory(boolean isSelfsined) throws Exception {

        SSLContext sslContext = null;
        SSLConnectionSocketFactory sslConnectionFactory = null;

        if (isSelfsined) {
            sslContext = SSLContexts.custom()
                    .loadTrustMaterial(null, new TrustSelfSignedStrategy())
                    .build();

            /*sslConnectionFactory = new SSLConnectionSocketFactory(sslContext,
                    new DefaultHostnameVerifier());*/

        } else {

            KeyStore identityKeyStore = KeyStore.getInstance("jks");
            identityKeyStore.load(new FileInputStream("keystore.ks"), "identity_password".toCharArray());

            KeyStore trustKeyStore = KeyStore.getInstance("jks");
            trustKeyStore.load(new FileInputStream("trust.jks"), "trust_password".toCharArray());

            sslContext = SSLContexts.custom()
                    // load identity keystore
                    .loadKeyMaterial(identityKeyStore, "identity_password".toCharArray(), new PrivateKeyStrategy() {
                        @Override
                        public String chooseAlias(Map<String, PrivateKeyDetails> aliases, Socket socket) {
                            return "identity_alias";
                        }
                    })
                    // load trust keystore
                    .loadTrustMaterial(trustKeyStore, null)
                    .build();
        }

        sslConnectionFactory = new SSLConnectionSocketFactory(sslContext,
                //ssl protocol versions
                new String[]{"TLSv1", "TLSv1.1", "TLSv1.2"},
                //CipherSuites
                null,
                new DefaultHostnameVerifier());


        return sslConnectionFactory;
    }


}
